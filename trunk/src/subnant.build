<?xml version="1.0" ?>
<!--
Copyright (C) 2005 Simon McKenna

Licensed under the GNU General Public License
http://www.gnu.org/copyleft/gpl.html

$Id$ 
-->
<project name="subnant" default="help" basedir=".">

    <description>Subversion administration using NAnt</description>

    <!-- Global properties -->
    <property name="subnant-started" value="${datetime::get-ticks(datetime::now())}"/>
    <!-- Use timestamp to greatly reduce risk of simultaneous calls using same log|result|output files -->
    <tstamp property="subnant-tstamp" pattern="yyyyMMdd-HHmmss-ffff"/>
    <property name="nant.onsuccess"  value="on-success"/>
    <property name="nant.onfailure"  value="on-failure"/>
    <!-- Subnant fails by default on <exec> errors, however some targets shouldn't fail on an svn error -->
    <property name="failonerror"    value="true"/>
    <property name="exec-output"    value="${path::combine(path::get-temp-path(),'exec-output-'+subnant-tstamp)}"/>
    <property name="exec-result"    value="${path::combine(path::get-temp-path(),'exec-result-'+subnant-tstamp)}"/>
    <property name="subnant-output" value="${path::combine(path::get-temp-path(),'subnant-output-'+subnant-tstamp)}"/>
    <property name="subnant-root"   value="${directory::get-parent-directory(directory::get-parent-directory(project::get-buildfile-path()))}"/>
    <property name="subnant-config" value="${path::combine(path::combine(subnant-root,'conf'),'subnant.config')}"/>

    <!-- Main targets (starts with default) -->
    <target name="help" description="Display help">
        <if test="${subnant::get-targets-count()==1}">
            <echo level="Warning">
                <![CDATA[Subversion administration using NAnt
Copyright (C) 2005 Simon McKenna
http://subnant.berlios.de

Usage: 
subnant <target> [<target>] [-D:<option>=<value>]

Global options:
sendmail        email result of <target> if property is set true
                (uses default in config) or set as email address

Examples:
subnant -projecthelp
subnant config
subnant help test
subnant test -D:sendmail=test@example.com
subnant hotcopy dump -D:sendmail=true
subnant create verify dump -D:repos=repo1,repo2
subnant migrate -D:to-svn-root=/svn2root/repos -D:to-svn-bindir=/svn2/bin]]>
            </echo>
        </if>
    </target>

    <!-- Repository (server) targets -->
    <target name="create" description="Create repositories"
        depends="init,init-repos,init-svnadmin">
        <nant buildfile="targets/server/create.build" target="${subnant::get-target()}"/>
    </target>

    <target name="dump" description="Dump repositories"
        depends="init,init-repos,init-svnadmin,init-svnlook,verify-repos-exists,build-repos-list">
        <nant buildfile="targets/server/dump.build" target="${subnant::get-target()}"/>
    </target>

    <target name="hotcopy" description="Hotcopy repositories"
        depends="init,init-repos,init-svnadmin,init-svnlook,verify-repos-exists,build-repos-list">
        <nant buildfile="targets/server/hotcopy.build" target="${subnant::get-target()}"/>
    </target>

    <target name="load" description="Load repositories"
        depends="init,init-repos,init-svnadmin">
        <nant buildfile="targets/server/load.build" target="${subnant::get-target()}"/>
    </target>

    <target name="migrate" description="Migrate repositories"
        depends="init,init-repos,init-svnadmin,verify-repos-exists,build-repos-list">
        <nant buildfile="targets/server/migrate.build" target="${subnant::get-target()}"/>
    </target>

    <target name="upgrade-bdb" description="Upgrade bdb repositories"
        depends="init,init-repos,init-svnadmin,verify-repos-exists,build-repos-list">
        <nant buildfile="targets/server/upgrade-bdb.build" target="${subnant::get-target()}"/>
    </target>

    <target name="verify" description="Verify repositories"
        depends="init,init-repos,init-svnadmin,verify-repos-exists,build-repos-list">
        <nant buildfile="targets/server/verify.build" target="${subnant::get-target()}"/>
    </target>

    <!-- Repository hooks targets -->
    <target name="commit-access" description="Control access to repository using pre-commit hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/commit-access.build" target="${subnant::get-target()}"/>
    </target>

    <target name="commit-allower" description="Control access to repository using start-commit hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/commit-allower.build" target="${subnant::get-target()}"/>
    </target>

    <target name="commit-email" description="Generate email about commits using post-commit hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/commit-email.build" target="${subnant::get-target()}"/>
    </target>

    <target name="commit-message" description="Ensure log message entered using pre-commit hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/commit-message.build" target="${subnant::get-target()}"/>
    </target>

    <target name="propchange-access" description="Control revision property access using pre-revprop hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/propchange-access.build" target="${subnant::get-target()}"/>
    </target>

    <target name="propchange-email" description="Email revision property changes using post-revprop hook"
        depends="init,init-repos,init-svnlook,verify-repos-exists">
        <nant buildfile="targets/server/hooks/propchange-email.build" target="${subnant::get-target()}"/>
    </target>

    <!-- Working copy (client) targets -->
    <target name="bugtraq" description="Set bugtraq props in working copy"
        depends="init,init-wc,init-svn,verify-wc-exists">
        <nant buildfile="targets/client/bugtraq.build" target="${subnant::get-target()}"/>
    </target>

    <!-- Other main targets -->
    <target name="config" description="Show subnant configuration"
        depends="init,init-repos">
        <nant buildfile="targets/config.build" target="${subnant::get-target()}"/>
    </target>

    <target name="install" description="Create subnant wrapper script"
        depends="init">
        <nant buildfile="targets/install.build" target="${subnant::get-target()}"/>
    </target>

    <target name="test" description="Test main targets"
        depends="init,init-repos,init-wc,init-svn,init-svnadmin,init-svnlook">
        <nant buildfile="targets/test.build" target="${subnant::get-target()}"/>
    </target>

    <!-- Sub targets -->
    <target name="init">
        <call target="init-subnant"/>
        <call target="init-logs" unless="${subnant::get-target()=='help'}"/>
    </target>

    <target name="init-subnant">
        <fail unless="${file::exists(subnant-config)}" message="File not found: ${path::get-file-name(subnant-config)}"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/nantcontrib-bindir" property="nantcontrib-bindir"/>
        <property name="nantcontrib-bindir" value="${nant::get-base-directory()}" unless="${string::get-length(string::trim(nantcontrib-bindir))>0 and directory::exists(nantcontrib-bindir)}"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/logs/logdir" property="logdir"/>
        <property name="logdir" value="${path::combine(subnant-root,'logs')}" if="${string::get-length(string::trim(logdir))==0}"/>
        <mkdir dir="${logdir}" unless="${directory::exists(logdir)}"/>
        <property name="nant-output" value="${path::combine(logdir,'subnant-'+subnant-tstamp+'.log')}"/>
        <loadtasks assembly="${path::combine(nantcontrib-bindir,'NAnt.Contrib.Tasks.dll')}"/>
        <!-- Note: Anything before this task will not be logged -->
        <record name="${nant-output}" level="Info" action="Start"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/svn-bindir" property="svn-bindir" unless="${property::exists('svn-bindir')}"/>
        <fail if="${string::get-length(svn-bindir)>0 and directory::exists(svn-bindir)!=true}" message="Subversion binary directory not found: ${svn-bindir}"/>
        <!-- ::TODO:: Investigate option for UTC instead of server localtime output? -->
        <echo message="Subnant started ${subnant::ticks-to-string(subnant-started)} (time in seconds unless noted)" file="${subnant-output}" append="false"/>
        <echo message="" file="${subnant-output}" append="true"/>
    </target>
   
    <target name="init-logs">
        <xmlpeek file="${subnant-config}" xpath="/configuration/logs/max-age" property="logs-max-age"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/logs/archive" property="archive"/>
        <property name="archive" value="${string::trim(string::to-lower(archive))}"/>
        <foreach item="File" property="log-file" if="${int::parse(logs-max-age)>=0}">
            <in>
                <items>
                    <include name="${path::combine(logdir,'*.log')}"/>
                    <exclude name="${nant-output}"/>
                </items>
            </in>
            <do>
                <if test="${file::get-last-write-time(log-file)&lt;(datetime::now()-timespan::from-days(logs-max-age)) and subnant::can-delete-file(log-file)}">
                    <zip if="${archive=='true'}" zipfile="${path::combine(logdir,'archive.zip')}" failonerror="false" ziplevel="9" comment="Subnant logs">
                        <fileset>
                            <!--<include name="${archived-logs}"/> ::TODO:: Append zip? Or unzip to temp and re-add? -->
                            <include name="${log-file}"/>
                            <exclude name="${nant-output}"/>
                        </fileset>
                    </zip>
                    <delete file="${log-file}"/>
                </if>
            </do>
        </foreach>
    </target>

    <target name="init-repos">
        <xmlpeek file="${subnant-config}" xpath="/configuration/svn-repos/svn-root" property="svn-root" unless="${property::exists('svn-root')}"/>
        <fail unless="${directory::exists(svn-root)}" message="Repository root directory doesn't exist: ${svn-root}"/>
    </target>

    <target name="init-wc">
        <property name="wc" value="${directory::get-current-directory()}" unless="${property::exists('wc')}"/>
    </target>

    <target name="init-svn">
        <property name="svn" value="${path::combine(svn-bindir,'svn')}"/>
    </target>

    <target name="init-svnadmin">
        <property name="svnadmin" value="${path::combine(svn-bindir,'svnadmin')}"/>
    </target>

    <target name="init-svnlook">
        <property name="svnlook" value="${path::combine(svn-bindir,'svnlook')}"/>
    </target>

    <target name="verify-repos-exists" if="${subnant::get-target()!='help'}">
        <if test="${property::exists('repos')}">
            <if test="${string::get-length(repos)==0}">
                <fail message="repos was set but no value entered"/>
            </if>
            <foreach item="String" in="${repos}" delim="," property="repo">
                <fail unless="${directory::exists(path::combine(svn-root,repo)) and file::exists(path::combine(svn-root,path::combine(repo,'format')))}"
                    message="Can't find repository ${repo} under ${svn-root}"/>
            </foreach>
        </if>
    </target>

    <target name="verify-wc-exists" if="${subnant::get-target()!='help'}">
        <fail if="${string::get-length(wc)==0}" message="Option wc was defined but no value set"/>
        <foreach item="String" in="${wc}" delim="," property="path">
            <ifnot test="${file::exists(path::combine(path,'.svn/format')) or file::exists(path::combine(path,'_svn/format'))}">
                <fail message="${path} is not a working copy"/>
            </ifnot>
        </foreach>
    </target>

    <target name="build-repos-list" if="${subnant::get-target()!='help'}">
        <ifnot test="${property::exists('repos')}">
            <property name="repos" value=""/>
            <foreach item="Folder" in="${svn-root}" property="repo">
                <do>
                    <loadfile file="${path::combine(repo,'format')}" property="fs-format" failonerror="false"/>
                    <if test="${int::parse(fs-format)>0}">
                        <property name="repos" value="${repos+subnant::return-directory-name(repo)+','}"/>
                    </if>
                </do>
            </foreach>
            <if test="${string::get-length(repos)>0}">
                <property name="repos" value="${string::substring(repos,0,string::get-length(repos)-1)}"/>
            </if>
            <if test="${string::get-length(repos)==0}">
                <fail message="No repositories found under ${svn-root}"/>
            </if>
        </ifnot>
    </target>

    <!-- Final targets -->
    <target name="on-success">
        <property name="subject" value="Success on ${subnant::get-build-targets()}"/>
        <if test="${property::exists('nant-output') and file::exists(nant-output)}">
            <record name="${nant-output}" action="Close" />
        </if>
        <call target="finally"/>
    </target>

    <target name="on-failure">
        <property name="subject" value="*** ERROR during ${subnant::get-build-targets()} ***"/>
        <if test="${property::exists('subnant-output') and file::exists(subnant-output)}">
            <property name="attach-output" value="true"/>
            <echo file="${subnant-output}" append="true" message="*** ERROR occurred - log attached ***"/>
        </if>
        <if test="${property::exists('nant-output') and file::exists(nant-output)}">
            <record name="${nant-output}" action="Close" />
        </if>
        <call target="finally"/>
    </target>

    <target name="finally">
        <call target="mail" if="${property::exists('sendmail') and string::trim(string::to-lower(sendmail))!='false'}"/>
        <call target="delete-temp-files"/>
    </target>

    <target name="mail">
        <fail unless="${property::exists('subnant-config')}" message="Email not sent as config file not yet set"/>
        <if test="${property::exists('subnant-output') and file::exists(subnant-output)}">
            <echo message="" file="${subnant-output}" append="true"/>
            <echo message="${string::pad-right('Subnant finished '+subnant::ticks-to-string(datetime::get-ticks(datetime::now())),60,' ')}(${subnant::format-elapsed-time(subnant-started, true)})" file="${subnant-output}" append="true"/>
            <loadfile file="${subnant-output}" property="message"/>
        </if>
        <ifnot test="${property::exists('subnant-output') and file::exists(subnant-output)}">
            <property name="message" value="No output generated by Subnant log (problem before record start? run from console for info)"/>
        </ifnot>
        <xmlpeek file="${subnant-config}" xpath="/configuration/mail/from"   property="mail-from"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/mail/host"   property="mail-host"/>
        <xmlpeek file="${subnant-config}" xpath="/configuration/mail/prefix" property="mail-prefix"/>
        <if test="${property::exists('sendmail')==true and string::trim(string::to-lower(sendmail))!='true'}">
            <property name="mail-tolist" value="${sendmail}"/>
        </if>
        <ifnot test="${property::exists('mail-tolist')}">
            <xmlpeek file="${subnant-config}" xpath="/configuration/mail/tolist" property="mail-tolist"/>
        </ifnot>
        <echo level="Warning">Sending mail to ${mail-tolist}</echo>
        <mail mailhost="${mail-host}" from="${mail-from}" tolist="${mail-tolist}" subject="${mail-prefix} ${subject}" message="${message}">
            <attachments>
                <include name="${nant-output}" if="${property::exists('attach-output') and file::exists(nant-output)}"/>
            </attachments>
        </mail>
    </target>

    <target name="delete-temp-files">
        <if test="${property::exists('subnant-output') and file::exists(subnant-output)}">
            <delete file="${subnant-output}"/>
        </if>
        <if test="${property::exists('exec-output') and file::exists(exec-output)}">
            <delete file="${exec-output}"/>
        </if>
        <if test="${property::exists('exec-result') and file::exists(exec-result)}">
            <delete file="${exec-result}"/>
        </if>
    </target>

    <!-- Custom functions and tasks, bundled into single <script> until NAnt 0.85rc4 released -->
    <script language="C#" prefix="subnant">
        <code>
            <![CDATA[
            /// <summary>
            /// Determines whether to call help or default subnant target
            /// </summary>
            [Function("get-target")]
            public string getSubnantTarget()
            {
                if (Project.BuildTargets.Contains("help"))
                {
                    return "help";
                }
                else
                {
                    return Project.CurrentTarget.Name;
                }
            }

            /// <summary>
            /// Return count of build targets, as help should display subnant usage
            /// if there is only one build target, rather than main targets help
            /// </summary>
            [Function("get-targets-count")]
            public int getSubnantTargetsCount()
            {
                return Project.BuildTargets.Count;
            }

            /// <summary>
            /// Display list of build targets   
            /// </summary>
            [Function("get-build-targets")]
            public string getSubnantBuildTargets()
            {
                String targets = String.Empty;
                System.Collections.Specialized.StringEnumerator targetEnumerator = Project.BuildTargets.GetEnumerator();

                while (targetEnumerator.MoveNext())
                {   
                    targets += targetEnumerator.Current+", ";
                }   

                if (targets.EndsWith(", "))
                {   
                    targets = targets.Substring(0, targets.Length-2);
                }   

                return targets;
            }

            /// <summary>
            /// NAnt path::get-directory-name() returns full path, sometimes we just want directory name
            /// </summary>
            [Function("return-directory-name")]
            public string getSubnantDirectoryName(string path)
            {
                DirectoryInfo directory = new DirectoryInfo(path);

                if (directory == null)
                {
                    return String.Empty;
                }
                else
                {
                    return directory.Name;
                }
            }

            /// <summary>
            /// Display DateTime string from ticks
            /// </summary>
            /// <param name="ticks">DateTime to convert</param>
            [Function("ticks-to-string")]
            public string getDateTimeFromTicks(Int64 ticks)
            {
                DateTime result = new DateTime(ticks);
                return result.ToString();
            }

            /// <summary>
            /// Subversion somtimes wants an Uri instead of path   
            /// </summary>
            /// <param name="path">Path to convert</param>
            [Function("to-uri")]
            public string pathToUriString(string path)
            {
                Uri pathToUri = new Uri(path);
                return pathToUri.ToString();
            }

            /// <summary>
            /// Display elapsed time using ticks for accuracy
            /// </summary>
            /// <param name="ticks">DateTime in ticks of end period</param>
            /// <param name="showText">Option to display time format, or show in seconds with no text</param>
            [Function("format-elapsed-time")]
            public string formatElapsedTime(long ticks, bool showText)
            {
                TimeSpan elapsed = TimeSpan.FromTicks(DateTime.Now.Ticks - ticks);

                if (!showText || (elapsed.TotalMinutes < 5))
                {
                    return String.Format("{0:F2}", elapsed.TotalSeconds);
                }
                else if (elapsed.TotalHours < 2)
                {
                    return String.Format("{0:F2} minutes", elapsed.TotalMinutes);
                }
                else
                {
                    return String.Format("{0:F2} hours", elapsed.TotalHours);
                }
            }

            /// <summary>
            /// Display length of file in Bytes or KB or MB or GB
            /// </summary>
            /// <param name="length">Length in bytes to convert</param>
            /// <param name="useKibi">Calculate and show in Kibi format</param>
            [Function("format-length")]
            public string formatLength(double length, bool useKibi)
            {
                int denominator = 1000;
                string kibi = String.Empty;

                if (useKibi)
                {
                    denominator = 1024;
                    kibi = "i";
                }

                // Unable to use switch as demoninator is not constant
                if (length < denominator)
                {
                    return String.Format("{0:F0} bytes", length);
                }
                else if (length < (denominator*denominator))
                {
                    return String.Format("{0:F2} K{1}B", (length/denominator), kibi);
                }
                else if (length < (denominator*denominator*denominator))
                {
                    return String.Format("{0:F2} M{1}B", ((length/denominator)/denominator), kibi);
                }
                else
                {
                    return String.Format("{0:F2} G{1}B", (((length/denominator)/denominator)/denominator), kibi);
                }
            }

            /// <summary>
            /// Build unique list of line separated directories recursing up
            /// to root node based upon line separated list of directories.
            /// Initial purpose is to convert 'svnlook dirs-changed' output
            /// so that all parent directories are tested once for hook-prop.
            /// </summary>
            /// <param name="dirsChanged">List of dirs-changed</param>
            [Function("build-dir-list")]
            public string buildDirList(string dirsChanged)
            {
                string[]  dirsList   = dirsChanged.Split(Environment.NewLine.ToCharArray());
                string[]  tempDirs;
                ArrayList dirsPath   = new ArrayList();
                string    dirsResult = String.Empty;
                string    tempPath   = String.Empty;
                string    dirSplit   = "/";

                foreach (string dir in dirsList)
                {
                    tempPath = String.Empty;
                    tempDirs = dir.Split(dirSplit.ToCharArray());

                    foreach (string path in tempDirs)
                    {
                        tempPath += path;
                        if (!tempPath.EndsWith(dirSplit))
                        {
                            tempPath += dirSplit;   
                        }   

                        // Add each directory to result if it isn't already in there
                        if (dirsPath.IndexOf(tempPath) < 0)
                        {
                            dirsPath.Add(tempPath);
                        }
                    }
                }

                dirsPath.Sort();
   
                foreach (string dir in dirsPath)
                {
                    dirsResult += dir + Environment.NewLine;
                }
 
                return dirsResult.Trim();
            }

            /// <summary>
            /// Try and open a file for appending to determine if file is able to be deleted.
            /// </summary>
            /// <param name="filename">File to test</param>
            [Function("can-delete-file")]
            public bool canDeleteFile(string filename)
            {
                try
                {
                   StreamWriter w = File.AppendText(filename);
                   w.Close();                
                }
                catch
                {
                    return false;
                }
                return true;
            }

            /// <summary>
            /// Write message to stderr
            /// </summary>
            [TaskName("stderr")]
            public class WriteStderr : Task
            {
                #region Private Instance Fields

                private string _message;

                #endregion Private Instance Fields

                #region Public Instance Properties

                [TaskAttribute("message", Required=true)]
                [StringValidator(AllowEmpty=false)]
                public string ErrorMessage
                {
                  get { return _message; }
                  set { _message = value; }
                }

                #endregion Public Instance Properties

                #region Override implementation of Task
                
                protected override void ExecuteTask()
                {
                    Console.Error.WriteLine(_message);
                }
                
                #endregion Override implementation of Task
            }]]>
        </code>
    </script>
  
</project>
